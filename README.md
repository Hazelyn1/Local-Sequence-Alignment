# Local-Sequence-Alignment
Python program that performs local sequence alignment of two DNA sequences, using a dynamic programming approach that is loosely based on the Smith-Waterman algorithm.

The program starts by taking user input for two DNA sequences. If the sequences are too long to be typed in, the program can be easisly adapted to take a file input. It then creates two dynamic programming matrices: one to hold the match scores, called "alignn_table" and another to hold the arrow assignments for each cell (i.e. points to which cell in the matrix that score came from) called "match_table" that is used for tracing back the alignment. Both of these matrices are initialized to all zeros.
The "score" function is then called, which takes six arguments: (1) the DP table "align_table", (2) the table for traceback "match_table", (3) input sequence 1, (4) input sequence 2, (5) length of sequence 1 and (6) length of sequence 2.

The score function starts by getting user input for the gap penalty, match score and mismatch scores. It then enters a doubly-nested for loop. The outer iterates the rows up to sequence 2 length + 1 (i), the inner loop iterates the columns up to sequence 1 length + 1 (j). 
Inside the inner loop, there are a variety of if statements that check the similarities between the two sequences. If the sequences match or mismatch, an alignment score is calculated (val1). If the position is not a match or mismatch, alignment scores val2 and val3 are calculated to indicate a gap either in sequence 1 (val2) or a gap in sequence 2 (val3). The maximum of val1, val2 and val3 is then taken and assigned to the DP table "dp_table" at [i][j]. If the max value is negative, then a value of zero is assigned instead.
Following this, the arrows in the match table are assigned. A match state is indicated by a left up diagonal arrow, a gap in sequence 1 is indicated by an up arrow and a gap in sequence 2 is indicated by a left arrow. In the case that it's a mismatch, a zero instead of an arrow is assigned. At this point, once all iterations are complete, the doubly-nested for loop exits.

To determine where the start the local alignment, the overall max alignment score in "dp_table" is determined. From here, the program enters another doubly-nested for loop, which finds the index in "dp_table" that holds the max value. The row (i) and column (j) are stored in variables x and y (respectively).
Now at the end of the score function, the traceback function is called to piece the local alignment together.

The traceback function has six arguments: (1) the DP table, (2) sequence 1, (3) sequence 2, (4) x, (5) y and (6) the max value of the DP table.
This function stores each aligned subsequence in a list, which are initialized as empty. The function then enters a while loop that checks if the DP table at the index x,y = 0. If so, the while loop terminates. Inisde the while loop are four if statements. The first if statement checks if "match_table" at index x,y contains a diagonal arrow. If so, it adds the matching bases of sequence 1 and sequence 2 to their respective lists and decrements x and y (moving up and to the left). The first elif statment checks if the arrow in "match_table" at index x,y is an up arrow. If so, a dash (-) is added to the subsequence 1 list and the base at index x-1 is added to the subsequence 2 list. The second elif statement checks if the arrow assingment at index x,y in "match_table" is a left arrow. If so, the base at index y-1 is added to the subsequence 1 list and a dash (-) is added to the subsequence 2 list. Lastly, the final else statement is for a mismatch case where "match_table" was assigned a zero at index x,y. In this case, no base is added to either subsequence list and both x and y are decremented.

Following while loop termination, the results are printed. First the alignment score, then the original sequences, then the aligned subsequences. 
